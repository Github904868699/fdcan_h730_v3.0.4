## 一、介绍
这是一个用于控制高擎机电电机的软件接口包。
通过这个接口包，用户可以方便地与高擎机电的电机进行通信，获取电机的状态信息，并控制电机的动作。
## 二、软件结构介绍
- **App：硬件**
    - `led`：负责LED灯的控制。
    - `my_fdcan`：与FDCAN硬件相关的功能实现。
- **Src：应用**
    - `convert`：负责单位转换，包括电机的位置、速度、加速度、力矩、电压、电流、PID以及**转（r）、弧度（rad）、度（°）**等单位的转换。
    - `livelybot_fdcan`：实现电机底层协议，处理原始数据。
    - `motor_control`：用于单电机控制，支持16种电机控制模式。
    - `motor_many`：用于一拖多模式的电机控制，支持12种电机控制模式。
    - `motor_config`：负责电机设置相关功能，包括带反馈的电机零位重置和电机设置保存。
    - `motor`：包含FDCAN接口通道映射、电机类型定义以及电机返回信息解析（包括FDCAN中断函数 `HAL_FDCAN_RxFifo0Callback` 的实现），***移植和使用的时候主要就是修改这个部分***。
- **test：测试**
	- `test_motor`：包含单电机函数使用例程和一些简单的控制。
	- `test_motor_many`：包含一拖多模式的函数使用例程和一些简单的控制。
## 三、移植和配置说明
- 如果没有移植需求可直接跳到 [2.配置](01-例程使用说明.md#^dd572c) 部分。
### 1. 移植
1. 将 `App` 文件夹下的 `my_fdcan` 文件夹和 `Src` 文件夹下的 `convert` 、`livelybot_fdcan` 、`motor_control` 、`motor_many`、`motor_config` 和 `motor` 5 个文件夹复制到新工程。
2. 将 `my_fdcan`、`convert` 、`livelybot_fdcan` 、`motor_control` 、`motor_many`、`motor_config` 和 `motor` 6 个文件夹都加入到头文件路径。
3. 在项目中包含头文件以下即可：
```C
#include "motor.h"
#include "motor_control.h"
#include "motor_many.h"
#include "motor_config.h"
```
4. 修改报错宏：在 `convert. h` 文件中，有用于检查某些配置或使用错误的宏，默认使用 `led_toggle_err` 所有 LED 同时闪烁报错，可根据需要自行修改。
	- `#include "led.h"` 这里引入 led 头文件只为使用 `led_toggle_err` 函数，如不需要直接删除即可。
```C
#include "led.h"


#ifdef  LED_ERR_FLAG  // 这个宏定义在 led.h 中
#define  MOTOR_ERR    led_toggle_err  // 所有 led 闪烁
#else
static inline void MOTOR_ERR(void) {}
#endif
```
5. 编辑成功，移植完成。
### 2. 配置（第一次使用时必须配置）

^dd572c
#### 2.1 修改 `motor.h` 中的宏定义
1. 修改宏定义 `MOTOR_MAX_NUM`，根据单个 CAN 通道需连接的最大电机数量修改。
	- 假设需要使用三个 CAN 通道，其中 CAN1 接 1 个电机，CAN2 接 2 个电机，CAN3 接 5 个电机，宏定义 `MOTOR_MAX_NUM` 修改为 5。
```C
#define  MOTOR_MAX_NUM  5
```
2. 修改宏定义 `MOTOR_PORT_NUM`，需要使用个 CAN 通道用于电机通讯就改成多少。
	- 假设 STM32G474 一共有三个 CAN 通道，其中 CAN1 和 CAN3 两个 CAN 通道用于连接电机，宏定义 `MOTOR_PORT_NUM` 修改为 2。
```C
#define  MOTOR_PORT_NUM   2  // 通道数量
```
#### 2.2 修改 `motor_state_port` 结构体数组（配置电机型号）
1. 在 `motor.c` 文件中，定义了 `motor_state_port[MOTOR_PORT_NUM][MOTOR_MAX_NUM]` 结构体数组，需要根据电机型号进行修改，以进行正确的力矩修正。
2. 假设我们一共要连接四个电机，每个通道连接两个电机，分布如下：
	1. PORT1:
		1. 4438_30
		2. 5047_36
	2. PORT2:
		1. 6056_36
		2. 5046_20
		则 `motor_state_port` 配置如下
```
static motor_state_s motor_state_port[MOTOR_PORT_NUM][MOTOR_MAX_NUM] =  // 下标 + 1 = 电机 ID
{
    {  // CAN 通道 PORT1
        {  // ID = 1
            .model = M4438_30,
        },

        {  // ID = 2
            .model = M5047_36,
        }
    },

    {  // CAN 通道 PORT2
        {  // ID = 1
            .model = M6056_36,
        },

        {  // ID = 2
            .model = M5046_20,
        }
    },
};
```
#### 2.3 修改 PORT、FDCAN、STATE 的映射关系
1. 在 `motor.c` 中，定义了结构体数组 `port_maping[MOTOR_PORT_NUM]` 用于定义 PORT、FDCAN、STATE 之间的映射关系。
2. 假设我们用到了 CAN2 和 CAN3 两个通道，我们希望定义
	- `CAN2`  映射到 `PORT1`，其状态数据存储在 `motor_state_port[0]`。
	- `CAN3`  映射到 `PORT2`，其状态数据存储在 `motor_state_port[1]`。
3. 则对应修改如下：
```C
const port_mapping_s port_maping[MOTOR_PORT_NUM] =  // 通道映射表
{
    {
        .port = PORT1,
        .fdcan = &hfdcan2,
        .state = motor_state_port[0],
    },

    {
        .port = PORT2,
        .fdcan = &hfdcan3,
        .state = motor_state_port[1],
    },
};
```
#### 2.4 修改位置速度的单位

^9934ce

- 位置和速度单位支持：**转（r）、弧度（rad）、或度（°）**，通过 `convert.h` 中的宏定义 `MOTOR_DATA_TYPE_FLAG` 进行切换，**默认为转（r）**。
1. 如果想使用**转 (r)** 做为位置速度的单位：
```C
#define  MOTOR_DATA_TYPE_FLAG  TURNS
```
2. 如果想使用 **弧度(rad)** 做为位置速度的单位：
```C
#define  MOTOR_DATA_TYPE_FLAG  RADIAN_2PI
```
3. 如果想使用 **角度(°)** 做为位置速度的单位：
```C
#define  MOTOR_DATA_TYPE_FLAG  ANGLE_360
```

## 四、函数示例
### 1. 单电机控制模式`motor_control.c`
- 此文件内，除电机软重启函数 `motor_set_reset` 外，都带有查询电机状态信息功能（解析函数位于 `motor.c` 文件）。
- 此文件内的所有函数都是调用后立即发送对应的 FDCAN 帧，无软件缓存。
- 此文件内的位置速度单位由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定，详情请看[修改位置速度的单位](#^9934ce)。
- 此文件内的控制方式控制频率不能过高，在仲裁段为 1M，数据段为 5M 的情况下，一个 CAN 总线 1ms 内最多控制 3 个电机，即 1KHz 控制频率下最多控制 3 个电机，如需控制更多电机，需降低控制频率或使用[一拖多控制模式](#^8eb0fa)（一个控制包括发送指令和接收电机状态信息）。
- 各个参数的单位在代码里的函数注释上都有详细说明。

#### 1.1 DQ 电压模式
**说明：**
- D 相电压默认为 0。
- Q 相电压由用户控制。
- 单位：伏(V)。
```C
void motor_set_dq_vlot(port_t portx, const data_type_t type, const uint8_t id, const float volt);
```
#### 1.2 DQ 电流模式
**说明：**
- D 相电流默认为 0。
- Q 相电流由用户控制。
- 单位：安(A)。
```C
void motor_set_dq_current(port_t portx, const data_type_t type, const uint8_t id, const float cur);
```
#### 1.3 位置模式
**说明：**
- 使用最大速度和加速度运动到目标位置。
- 正负表示方向。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_set_pos(port_t portx, const data_type_t type, const uint8_t id, const float pos);
```
#### 1.4 速度模式
**说明：**
- 以设置速度转动。
- 正负表示方向。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_set_vel(port_t portx, const data_type_t type, const uint8_t id, const float vel);
```
#### 1.5 力矩模式
**说明：**
- 以给定的力矩转动。
- 正负表示方向。
- 单位：牛米（NM）。
```C
void motor_set_tqe(port_t portx, const data_type_t type, const uint8_t id, const float tqe);
```
#### 1.6 位置、速度模式
**说明：**
- 以目标速度运动到目标位置，不限制加速度和最大输出力矩。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_set_pos_vel(port_t portx, const data_type_t type, const uint8_t id, const float pos, const float vel);
```
#### 1.7 位置、速度、最大力矩模式
**说明：**
- 以目标速度运动到目标位置，并限制最大输出力矩（并让电机返回状态信息）。
- 不想控制力矩可直接给一个很大的值或者无限（NAN）。
- 单位：
	- 位置、速度：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
	- 最大力矩：牛米（NM）。
```C
void motor_set_pos_vel_MAXtqe(port_t portx, const data_type_t type, const uint8_t id, const float pos, const float vel, const float tqe);
```
#### 1.8 位置、速度、加速度模式（梯形控制）
**说明：**
- 指定电机转动到某个位置，并限制转动过程中的最大速度和加速度。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_set_pos_velmax_acc(port_t portx, const data_type_t type, const uint8_t id, const float pos, const float vel, const float acc);
```

#### 1.9 速度、加速度模式
**说明：**
- 以目标加速度加速到目标速度。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_set_vel_acc(port_t portx, const data_type_t type, const uint8_t id, const float vel, const float acc);
```
#### 1.10 运控模式
**说明：**
- **输出力矩 = 位置偏差 * kp + 速度偏差 * kd + tqe**。
- **单位：**
	- 位置、速度：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
	- 力矩：牛米(NM)。
```C
/* 不建议使用 */
void motor_set_pos_vel_tqe_kp_kd(port_t portx, const data_type_t type, const uint8_t id, const float pos, const float vel, const float tqe, const float kp, const float kd);

/* 建议使用 */
void motor_set_pos_vel_tqe_kp_kd_2(port_t portx, const data_type_t type, const uint8_t id, const float pos, const float vel, const float tqe, const float kp, const float kd);
```

#### 1.11 查询电机状态信息
**说明：**
- 发送查询电机状态信息的指令。
- 电机返回的状态信息包括，模式、错误码、位置、速度、力矩。
- 电机状态信息解析在 `motor.c` 的 `motor_process_state` 函数。
```C
void motor_get_state_send(port_t portx, const data_type_t type, const uint8_t id);
```

#### 1.12 查询电机固件版本
**说明：**
- 发送查询电机固件版本号指令。
- 电机固件版本解析在 `motor.c` 的 `motor_process_state` 函数。
```C
void motor_get_version(port_t portx, const uint8_t id);
```

#### 1.13 停止模式
**说明：**
- 电机三相都断开。
```C
void motor_set_stop(port_t portx, const uint8_t id);
```

#### 1.14 刹车模式
**说明：**
- 电机所有相都短接到地，产生被动的“刹车”效果。
```C
void motor_set_brake(port_t portx, const uint8_t id);
```

#### 1.15 电机软重启
**说明：**
- 电机软重启，重启后进入停止模式。
- 不会有任何反馈。
```C
void motor_set_reset(port_t portx, const uint8_t id);
```
### 2. 一拖多控制模式 `motor_many.c`

^8eb0fa
- 此文件内，只有 `motor_many_send` 是用于发送指令的，其他的函数都是向缓存写入指令。
- 一拖多模式下，同一条CAN 通道上的电机模式是相同的。
- 一拖多模式大致原理，发送一条通用的FDCAN 帧，帧上不同的字节控制不同电机，其中由ID 确定电机模式，详细说明请看 [02-fdcan协议解析](02-fdcan协议解析.md)。
- 一拖多模式下，在仲裁段为 1M，数据段为 5M 的情况下，一个 CAN 总线 1ms 内最多控制 10 个电机，即 1KHz 控制频率下最多控制 10 个电机，如需控制更多电机，需降低控制频率。
- 一拖多模式**使用说明**：
```C
/* 写入缓存 */
motor_many_vel(PORT1, 1, 0.1);
motor_many_vel(PORT1, 2, 0.1);
motor_many_vel(PORT1, 3, 0.1);

/* 发送指令 */
motor_many_send(PORT1);
```
#### 2.1 DQ 电压模式
**说明：**
- D 相电压默认为 0。
- Q 相电压由用户控制。
- 单位：伏 (V)。
```C
void motor_many_dq_volt(port_t portx, const uint8_t id, const float vol);
```
#### 2.2 DQ 电流模式
**说明：**
- D 相电流默认为 0。
- Q 相电流由用户控制。
- 单位：安 (A)。
```C
void motor_many_dq_current(port_t portx, const uint8_t id, const float cur);
```
#### 2.3 位置模式
**说明：**
- 使用最大速度和加速度运动到目标位置。
- 正负表示方向。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_many_pos(port_t portx, const uint8_t id, const float pos);
```
#### 2.4 速度模式
**说明：**
- 以设置速度转动。
- 正负表示方向。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_many_vel(port_t portx, const uint8_t id, const float vel);
```
#### 2.5 力矩模式
**说明：**
- 以给定的力矩转动。
- 正负表示方向。
- 单位：牛米（NM）。
```C
void motor_many_tqe(port_t portx, const uint8_t id, const float tqe);
```
#### 2.6 位置、速度模式
**说明：**
- 以目标速度运动到目标位置，不限制加速度和最大输出力矩。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_many_pos_vel(port_t portx, const uint8_t id, const float pos, const float vel);
```
#### 2.7 位置、速度、最大力矩模式
**说明：**
- 以目标速度运动到目标位置，并限制最大输出力矩（并让电机返回状态信息）。
- 不想控制力矩可直接给一个很大的值或者无限（NAN）。
- 单位：
	- 位置、速度：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
	- 最大力矩：牛米（NM）。
```C
void motor_many_pos_vel_MAXtqe(port_t portx, const uint8_t id, const float pos, const float vel, const float tqe);
```
#### 2.8 位置、速度、加速度模式（梯形控制）
**说明：**
- 指定电机转动到某个位置，并限制转动过程中的最大速度和加速度。
- 单位：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
```C
void motor_many_pos_vel_acc(port_t portx, const uint8_t id, const float pos, const float vel, const float acc);
```
#### 2.9 运控模式
**说明：**
- **输出力矩 = 位置偏差 * kp + 速度偏差 * kd + tqe**。
- **单位：**
	- 位置、速度：由宏定义 `MOTOR_DATA_TYPE_FLAG` 决定。
	- 力矩：牛米 (NM)。
```C
/* 不建议使用 */
void motor_many_pos_vel_tqe_kp_kd(port_t portx, const uint8_t id, const float pos, const float vel, const float tqe, const float kp, const float kd);

/* 建议使用 */
void motor_many_pos_vel_tqe_kp_kd_2(port_t portx, const uint8_t id, const float pos, const float vel, const float tqe, const float kp, const float kd);
```

### 3. 电机设置 `motor_config`
- 此文件内的函数都是用于电机设置相关。
#### 3.1 重置电机零位
**说明：**
- 将电机当前位置设置成零位。
- 重置一个电机的零位需要要 300ms 以上，且有失败可能。
- 返回值：0-成功，1-失败。
```C
uint8_t motor_pos_reset(port_t portx, const uint8_t id);
```
#### 3.2 保存电机设置
**说明：**
- 保存电机设置。
- 一般配合其他指令运行。
- 返回值：0-成功，1-失败。
```C
uint8_t motor_conf_write(port_t portx, const uint8_t id);
```

### 4. 电机配置和协议解析 `motor`
- 此文件中定义了两个重要的结构体数组：详见 [2.配置](#^dd572c)
	- `motor_state_port[MOTOR_PORT_NUM][MOTOR_MAX_NUM]`：用于配置电机型号和储存电机返回的信息。
	- `port_maping[MOTOR_PORT_NUM]`：用于配置 PORT、FDCAN 和 STATE 的映射关系。
#### 4.1 电机信息解析
**说明：**
- 解析所有 CAN 通道 FIFO 中的电机状态数据。
- 此函数中调用 `motor_process_state` 进行解析。
- **此函数需要放在主循环中不断调用，也可根据需求定时调用**。
```C
void motor_process_state_all();
```
